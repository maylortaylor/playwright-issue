"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createPlugin = createPlugin;
var _utilsBundle = require("playwright-core/lib/utilsBundle");
var _fs = _interopRequireDefault(require("fs"));
var _path = _interopRequireDefault(require("path"));
var _babelBundle = require("playwright/lib/transform/babelBundle");
var _utilsBundle2 = require("playwright/lib/utilsBundle");
var _utils = require("playwright-core/lib/utils");
var _compilationCache = require("playwright/lib/transform/compilationCache");
var _tsxTransform = require("./tsxTransform");
var _vite = require("vite");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const log = (0, _utilsBundle.debug)('pw:vite');
let stoppableServer;
const playwrightVersion = (0, _utils.getPlaywrightVersion)();
const importReactRE = /(^|\n|;)import\s+(\*\s+as\s+)?React(,|\s+)/;
const compiledReactRE = /(const|var)\s+React\s*=/;
function createPlugin(registerSourceFile, frameworkPluginFactory) {
  let configDir;
  let config;
  return {
    name: 'playwright-vite-plugin',
    setup: async (configObject, configDirectory) => {
      config = configObject;
      configDir = configDirectory;
    },
    begin: async suite => {
      var _baseAndUserConfig$pl;
      // We are going to have 3 config files:
      // - the defaults that user config overrides (baseConfig)
      // - the user config (userConfig)
      // - frameworks overrides (frameworkOverrides);

      const use = config.projects[0].use;
      const port = use.ctPort || 3100;
      const host = use.baseURL || 'localhost';
      const relativeTemplateDir = use.ctTemplateDir || 'playwright';

      // FIXME: use build plugin to determine html location to resolve this.
      // TemplateDir must be relative, otherwise we can't move the final index.html into its target location post-build.
      // This regressed in https://github.com/microsoft/playwright/pull/26526
      const templateDir = _path.default.join(configDir, relativeTemplateDir);

      // Compose base config from the playwright config only.
      const baseConfig = {
        root: configDir,
        configFile: false,
        define: {
          __VUE_PROD_DEVTOOLS__: true
        },
        css: {
          devSourcemap: true
        },
        build: {
          outDir: use.ctCacheDir ? _path.default.resolve(configDir, use.ctCacheDir) : _path.default.resolve(templateDir, '.cache')
        },
        preview: {
          port,
          host
        },
        // Vite preview server will otherwise always return the index.html with 200.
        appType: 'custom'
      };

      // Apply user config on top of the base config. This could have changed root and build.outDir.
      const userConfig = typeof use.ctViteConfig === 'function' ? await use.ctViteConfig() : use.ctViteConfig || {};
      const baseAndUserConfig = (0, _vite.mergeConfig)(baseConfig, userConfig);
      const buildInfoFile = _path.default.join(baseAndUserConfig.build.outDir, 'metainfo.json');
      let buildExists = false;
      let buildInfo;
      const registerSource = await _fs.default.promises.readFile(registerSourceFile, 'utf-8');
      const registerSourceHash = (0, _utils.calculateSha1)(registerSource);
      try {
        buildInfo = JSON.parse(await _fs.default.promises.readFile(buildInfoFile, 'utf-8'));
        (0, _utils.assert)(buildInfo.version === playwrightVersion);
        (0, _utils.assert)(buildInfo.viteVersion === _vite.version);
        (0, _utils.assert)(buildInfo.registerSourceHash === registerSourceHash);
        buildExists = true;
      } catch (e) {
        buildInfo = {
          version: playwrightVersion,
          viteVersion: _vite.version,
          registerSourceHash,
          components: [],
          tests: {},
          sources: {}
        };
      }
      log('build exists:', buildExists);
      const componentRegistry = new Map();
      // 1. Re-parse changed tests and collect required components.
      const hasNewTests = await checkNewTests(suite, buildInfo, componentRegistry);
      log('has new tests:', hasNewTests);

      // 2. Check if the set of required components has changed.
      const hasNewComponents = await checkNewComponents(buildInfo, componentRegistry);
      log('has new components:', hasNewComponents);

      // 3. Check component sources.
      const sourcesDirty = !buildExists || hasNewComponents || (await checkSources(buildInfo));
      log('sourcesDirty:', sourcesDirty);

      // 4. Update component info.
      buildInfo.components = [...componentRegistry.values()];
      const frameworkOverrides = {
        plugins: []
      };

      // React heuristic. If we see a component in a file with .js extension,
      // consider it a potential JSX-in-JS scenario and enable JSX loader for all
      // .js files.
      if (hasJSComponents(buildInfo.components)) {
        log('jsx-in-js detected');
        frameworkOverrides.esbuild = {
          loader: 'jsx',
          include: /.*\.jsx?$/,
          exclude: []
        };
        frameworkOverrides.optimizeDeps = {
          esbuildOptions: {
            loader: {
              '.js': 'jsx'
            }
          }
        };
      }

      // We assume that any non-empty plugin list includes `vite-react` or similar.
      if (frameworkPluginFactory && !((_baseAndUserConfig$pl = baseAndUserConfig.plugins) !== null && _baseAndUserConfig$pl !== void 0 && _baseAndUserConfig$pl.length)) frameworkOverrides.plugins = [await frameworkPluginFactory()];

      // But only add out own plugin when we actually build / transform.
      if (sourcesDirty) frameworkOverrides.plugins.push(vitePlugin(registerSource, templateDir, buildInfo, componentRegistry));
      frameworkOverrides.build = {
        target: 'esnext',
        minify: false,
        rollupOptions: {
          treeshake: false,
          input: {
            index: _path.default.join(templateDir, 'index.html')
          }
        },
        sourcemap: true
      };
      const finalConfig = (0, _vite.mergeConfig)(baseAndUserConfig, frameworkOverrides);
      if (sourcesDirty) {
        log('build');
        await (0, _vite.build)(finalConfig);
        await _fs.default.promises.rename(`${finalConfig.build.outDir}/${relativeTemplateDir}/index.html`, `${finalConfig.build.outDir}/index.html`);
      }
      if (hasNewTests || hasNewComponents || sourcesDirty) {
        log('write manifest');
        await _fs.default.promises.writeFile(buildInfoFile, JSON.stringify(buildInfo, undefined, 2));
      }
      for (const [filename, testInfo] of Object.entries(buildInfo.tests)) {
        const deps = new Set();
        for (const componentName of testInfo.components) {
          const component = componentRegistry.get(componentName);
          component === null || component === void 0 ? void 0 : component.deps.forEach(d => deps.add(d));
        }
        (0, _compilationCache.setExternalDependencies)(filename, [...deps]);
      }
      const previewServer = await (0, _vite.preview)(finalConfig);
      stoppableServer = (0, _utilsBundle2.stoppable)(previewServer.httpServer, 0);
      const isAddressInfo = x => x === null || x === void 0 ? void 0 : x.address;
      const address = previewServer.httpServer.address();
      if (isAddressInfo(address)) {
        const protocol = finalConfig.preview.https ? 'https:' : 'http:';
        process.env.PLAYWRIGHT_TEST_BASE_URL = `${protocol}//${finalConfig.preview.host}:${address.port}`;
      }
    },
    end: async () => {
      if (stoppableServer) await new Promise(f => stoppableServer.stop(f));
    }
  };
}
async function checkSources(buildInfo) {
  for (const [source, sourceInfo] of Object.entries(buildInfo.sources)) {
    try {
      const timestamp = (await _fs.default.promises.stat(source)).mtimeMs;
      if (sourceInfo.timestamp !== timestamp) {
        log('source has changed:', source);
        return true;
      }
    } catch (e) {
      log('check source failed:', e);
      return true;
    }
  }
  return false;
}
async function checkNewTests(suite, buildInfo, componentRegistry) {
  const testFiles = new Set();
  for (const project of suite.suites) {
    for (const file of project.suites) testFiles.add(file.location.file);
  }
  let hasNewTests = false;
  for (const testFile of testFiles) {
    var _buildInfo$tests$test;
    const timestamp = (await _fs.default.promises.stat(testFile)).mtimeMs;
    if (((_buildInfo$tests$test = buildInfo.tests[testFile]) === null || _buildInfo$tests$test === void 0 ? void 0 : _buildInfo$tests$test.timestamp) !== timestamp) {
      const components = await parseTestFile(testFile);
      log('changed test:', testFile);
      for (const component of components) componentRegistry.set(component.fullName, component);
      buildInfo.tests[testFile] = {
        timestamp,
        components: components.map(c => c.fullName)
      };
      hasNewTests = true;
    }
  }
  return hasNewTests;
}
async function checkNewComponents(buildInfo, componentRegistry) {
  const newComponents = [...componentRegistry.keys()];
  const oldComponents = new Map(buildInfo.components.map(c => [c.fullName, c]));
  let hasNewComponents = false;
  for (const c of newComponents) {
    if (!oldComponents.has(c)) {
      hasNewComponents = true;
      break;
    }
  }
  for (const c of oldComponents.values()) componentRegistry.set(c.fullName, c);
  return hasNewComponents;
}
async function parseTestFile(testFile) {
  const text = await _fs.default.promises.readFile(testFile, 'utf-8');
  const ast = (0, _babelBundle.parse)(text, {
    errorRecovery: true,
    plugins: ['typescript', 'jsx'],
    sourceType: 'module'
  });
  const componentUsages = (0, _tsxTransform.collectComponentUsages)(ast);
  const componentNames = componentUsages.names;
  const result = [];
  (0, _babelBundle.traverse)(ast, {
    enter: p => {
      if (_babelBundle.types.isImportDeclaration(p.node)) {
        const importNode = p.node;
        if (!_babelBundle.types.isStringLiteral(importNode.source)) return;
        for (const specifier of importNode.specifiers) {
          const specifierName = specifier.local.name;
          const componentName = componentNames.has(specifierName) ? specifierName : [...componentNames].find(c => c.startsWith(specifierName + '.'));
          if (!componentName) continue;
          if (_babelBundle.types.isImportNamespaceSpecifier(specifier)) continue;
          result.push((0, _tsxTransform.componentInfo)(specifier, importNode.source.value, testFile, componentName));
        }
      }
    }
  });
  return result;
}
function vitePlugin(registerSource, templateDir, buildInfo, componentRegistry) {
  buildInfo.sources = {};
  let moduleResolver;
  return {
    name: 'playwright:component-index',
    configResolved(config) {
      moduleResolver = config.createResolver();
    },
    async transform(content, id) {
      const queryIndex = id.indexOf('?');
      const file = queryIndex !== -1 ? id.substring(0, queryIndex) : id;
      if (!buildInfo.sources[file]) {
        try {
          const timestamp = (await _fs.default.promises.stat(file)).mtimeMs;
          buildInfo.sources[file] = {
            timestamp
          };
        } catch {
          // Silent if can't read the file.
        }
      }

      // Vite React plugin will do this for .jsx files, but not .js files.
      if (id.endsWith('.js') && content.includes('React.createElement') && !content.match(importReactRE) && !content.match(compiledReactRE)) {
        const code = `import React from 'react';\n${content}`;
        return {
          code,
          map: {
            mappings: ''
          }
        };
      }
      const indexTs = _path.default.join(templateDir, 'index.ts');
      const indexTsx = _path.default.join(templateDir, 'index.tsx');
      const indexJs = _path.default.join(templateDir, 'index.js');
      const indexJsx = _path.default.join(templateDir, 'index.jsx');
      const idResolved = _path.default.resolve(id);
      if (!idResolved.endsWith(indexTs) && !idResolved.endsWith(indexTsx) && !idResolved.endsWith(indexJs) && !idResolved.endsWith(indexJsx)) return;
      const folder = _path.default.dirname(id);
      const lines = [content, ''];
      lines.push(registerSource);
      for (const [alias, value] of componentRegistry) {
        const importPath = value.isModuleOrAlias ? value.importPath : './' + _path.default.relative(folder, value.importPath).replace(/\\/g, '/');
        if (value.importedName) lines.push(`const ${alias} = () => import('${importPath}').then((mod) => mod.${value.importedName + (value.importedNameProperty || '')});`);else lines.push(`const ${alias} = () => import('${importPath}').then((mod) => mod.default${value.importedNameProperty || ''});`);
      }
      lines.push(`pwRegister({ ${[...componentRegistry.keys()].join(',\n  ')} });`);
      return {
        code: lines.join('\n'),
        map: {
          mappings: ''
        }
      };
    },
    async writeBundle() {
      for (const component of componentRegistry.values()) {
        const id = await moduleResolver(component.importPath);
        if (!id) continue;
        const deps = new Set();
        collectViteModuleDependencies(this, id, deps);
        component.deps = [...deps];
      }
    }
  };
}
function collectViteModuleDependencies(context, id, deps) {
  if (!_path.default.isAbsolute(id)) return;
  const normalizedId = _path.default.normalize(id);
  if (deps.has(normalizedId)) return;
  deps.add(normalizedId);
  const module = context.getModuleInfo(id);
  for (const importedId of (module === null || module === void 0 ? void 0 : module.importedIds) || []) collectViteModuleDependencies(context, importedId, deps);
  for (const importedId of (module === null || module === void 0 ? void 0 : module.dynamicallyImportedIds) || []) collectViteModuleDependencies(context, importedId, deps);
}
function hasJSComponents(components) {
  for (const component of components) {
    const extname = _path.default.extname(component.importPath);
    if (extname === '.js' || !extname && _fs.default.existsSync(component.importPath + '.js')) return true;
  }
  return false;
}